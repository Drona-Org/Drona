[
   modules.C = '"C at C.4ml"'
]

domain PLink
{
	IdList  ::= new (val: Integer + String, tl: any IdList + { NIL }).
	Id ::= { NIL } + Integer + String + IdList.
	NonNullEventName  ::= String + { HALT }.
	EventName         ::= String + { NULL, HALT }.
	EventNameList ::= new (hd: EventName, tl: any EventNameList + { NIL }).

	NameType        ::= new (name: String).
    BaseType        ::= new ({ NULL, BOOL, INT, EVENT, MACHINE, ANY }).
    TupType         ::= new (hd: any TypeExpr, tl: any TupType + { NIL }).
    NmdTupType      ::= new (hd: any NmdTupTypeField, tl: any NmdTupType + { NIL }).
    SeqType         ::= new (x: any TypeExpr).
    MapType         ::= new (k: any TypeExpr, v: any TypeExpr).
    NmdTupTypeField ::= new (name: any String, type: any TypeExpr). 
	InterfaceType	::= new (ev: NonNullEventName, tail: any InterfaceType + {NIL}).
    TypeExpr        ::= NameType + BaseType + TupType + NmdTupType + SeqType + MapType + InterfaceType.

	StringList		::= new (hd: String, tl: any StringList + { NIL }).
	IntegerList		::= new (hd: Integer, tl: any IntegerList + { NIL }).
	EnumTypeDef	    ::= fun (name: String -> elems: any StringList, values: any IntegerList + { NIL }).
	TypeDef         ::= fun (name: String -> type: any TypeExpr).
	ModelType       ::= new (name: String).

    AssumeMaxInstances	::= new (bound: Natural).
    AssertMaxInstances	::= new (bound: Natural).
    QueueConstraint		::= AssumeMaxInstances + AssertMaxInstances + { NIL }.
    EventDecl			::= fun (name: String -> card: any QueueConstraint, type: any TypeExpr + { NIL }).
	PermEmbeddedInEvent ::= fun (name: NonNullEventName -> perm: NonNullEventName).
	PermEmbeddedInConstType ::= fun (machName: String -> perm: NonNullEventName).
	AnonFunDecl		    ::= new (ownerFun: String, anonFunIndex: Natural).
	FunDecl				::= fun (name: String -> params: any NmdTupType + { NIL }, return: any TypeExpr + { NIL }, id: any Id).
	FunProtoDecl		::= fun (name: String -> params: any NmdTupType + { NIL }, return: any TypeExpr + { NIL }).
	Impure				::= new (decl: FunDecl + FunProtoDecl).
	EventSet			::= fun (name: String -> list: any EventNameList + { NIL }).
	InterfaceTypeDecl	::= fun (name: String -> list: EventNameList, argType: any TypeExpr).
    MachineDecl			::= fun (name: String -> constType: any TypeExpr, id: any Id).
	MonitorDecl			::= fun (name: String -> obsList: EventNameList, id: any Id).
	MachineProtoDecl	::= new (name: String, constType: any TypeExpr).
	

	AvailableParameterDemand   ::= new (fname: String, pname: String).
	UnavailableParameterSupply ::= new (fname: String, pname: String).

	/*****************************************************************/
	/*		Module system related declarations and constructs		 */
	/*****************************************************************/

	//// Machine Signature
	MachineExports		::= fun (mach: String -> exports: String).
	MachineReceives		::= new (mach: String, ev: NonNullEventName).
	MachineSends		::=	new (mach: String, ev: NonNullEventName).
	MachineCreatesInt	::= new (mach: String, iname: String).
	MachineCreatesM		::= new (mach: String, mmname: String).

	//// Module Declarations
	ModuleDecl ::= fun (name: String -> id: any Id).
	ModuleContains ::= new (mod: ModuleDecl, mach: String).
	ModulePrivateEvents ::= new (mod: ModuleDecl, ev: NonNullEventName + { NIL }).
	ModuleName ::= fun (name: String -> id: any Id).
	

	/// Module Constructions
	ModuleDef ::= fun (name: String -> mod: any ModuleExpr).
	HideExpr ::= new (evtNames: any EventNameList, mod: any ModuleExpr, id: any Id). 
	RenameExpr ::= new (mNames: String, mNames': String, mod: any ModuleExpr, id: any Id).
	ExportExpr ::= new (mName: String, iName: String, mod: any ModuleExpr, id: any Id).
	AssumeExpr ::= new (monNames: any MonitorNameList, mod: any ModuleExpr, id: any Id).
	AssertExpr ::= new (monNames: any MonitorNameList, mod: any ModuleExpr, id: any Id).
	SafeExpr ::= new (mod: any ModuleExpr, id: any Id).
	ComposeExpr ::= new (left: any ModuleExpr, right: any ModuleExpr, id: any Id).
	ModuleExpr ::= ModuleName + HideExpr + RenameExpr + ExportExpr + AssumeExpr + AssertExpr + SafeExpr + ComposeExpr + ModuleDecl.

	

	//// Test Declarations and Implementation
	TestDecl ::= fun (name: String -> mod: any ModuleExpr, id: any Id).
	RefinementDecl ::= fun (name: String -> lhs: any ModuleExpr, rhs: any ModuleExpr, id: any Id).
	ImplementationDecl ::= fun (mod: any ModuleExpr -> id: any Id).

	//// Module Signature 
	ModulePrivate ::= (mod: ModuleExpr, ev: NonNullEventName).
	ModuleSends ::= (mod: ModuleExpr, ev: NonNullEventName).
	ModuleReceives ::= (mod: ModuleExpr, ev: NonNullEventName).
	ModuleExports ::= (mod: ModuleExpr, i: String).  
	ModuleCreates ::= (mod: ModuleExpr, i: String).

	//// Module Code Gen and Compatibity Helpers
	ModuleLinkMap ::= (mod: ModuleExpr, newMachineName: String, interfaceOrMachine: String + { NIL }, newImpMachine: String + { NIL }).
	ModuleRenameMap ::= (mod: ModuleExpr, newName: String, impMachine: String).  // for both machines and monitors
	ModuleSafeMap ::= (mod: ModuleExpr, newName: String, isSafe: Boolean).
	ModuleMonitorMap ::= (mod: ModuleExpr, newMonitorName: String, impMachine: String).

	// MonitorNamesList
	MonitorNameList ::= new (str: String, tl: any MonitorNameList + { NIL }).
	MemberOfMonitorNameList ::= sub (MonitorNameList, String).
	MemberOfEventNameList ::= sub (EventNameList, EventName).

}

domain PLinkError
{
	/* Rules:
    (1) The last arg of the error term is always the error message. 
    (2) The first arg is of type Id, is the span info otherwise the span info is default.
    */
	IdList  ::= new (val: Integer + String, tl: any IdList + { NIL }).
	Id ::= { NIL } + Integer + String + IdList.
	EventName         ::= String + { NULL, HALT }.
	EventNameList ::= new (hd: EventName, tl: any EventNameList + { NIL }).

	//// General linker errors
	OneNameError ::= new (errorId: any Id, name: String, msg: String).
	TwoNameError ::= new (errorId: any Id, name1: String, name2: String, msg: String).

	//// Module system related linker errors
	ModuleDefError ::= new (errorId: any Id, name: String, msg: String).
	NoMainMachineInModExpr ::= new (modExprId: any Id, msg: String).
	ModuleConstructionIllegal ::= new (modExprId: any Id, arg: String + { HALT }, msg: String).
	WellFormednessError ::= new (modExprId: any Id, arg: String + { HALT }, msg: String).
	TestOrImplDeclError ::= new (modExprId: any Id, arg: String, msg: String).
	RefinementDeclError ::= new (modExprId: any Id, arg: String + { HALT }, msg: String).

	
	CSharpLinkMap ::= new (testName: String, newMachineName: String, interfaceOrMachine: String, newImpMachine: String).
	CSharpRenameMap ::= new (testName: String, newName: String, impMachine: String).
	CSharpSafeMap ::= new (testName: String, newName: String, isSafe: Boolean).
	CSharpMonitorMap ::= new (testName: String, newMonitorName: String, impMachine: String).

	TestError ::= new (modId: String, arg: any String).
}

transform PLink2C(in:: PLink) returns (err:: PLinkError, out:: C)
{
	//// General Linker Errors
	err.OneNameError(NIL, name, "multiple machines with same name") :- m is MachineDecl, m' is MachineDecl, m != m', m.name = m'.name, name = m.name.

	err.OneNameError(NIL, name, "multiple functions with same name") :- f is FunDecl, f' is FunDecl, f != f', f.name = f'.name, name = f.name.

	err.OneNameError(NIL, mp.name, "machine prototype not implemented") :- mp is MachineProtoDecl, no MachineDecl(mp.name, _, _).
	
	err.OneNameError(NIL, mp.name, "constructor type does not match") :- mp is MachineProtoDecl, m is MachineDecl, mp.name = m.name, mp.constType != m.constType.
	
	err.OneNameError(NIL, fp.name, "parameter type does not match") :- fp is FunProtoDecl, f is FunDecl, fp.name = f.name, fp.params != f.params.
	err.OneNameError(NIL, fp.name, "return type does not match") :- fp is FunProtoDecl, f is FunDecl, fp.name = f.name, fp.return != f.return.

	err.OneNameError(NIL, fp.name, "function prototype not implemented") :- fp is FunProtoDecl, no FunDecl(fp.name, _, _, _).

	err.OneNameError(NIL, iname, "machine cannot have the same name as interface") :- i is InterfaceTypeDecl(iname, _, _), MachineDecl(iname, _, _).
	err.OneNameError(NIL, iname, "machine prototype cannot have the same name as interface") :- i is InterfaceTypeDecl(iname, _, _), MachineProtoDecl(iname, _).

	err.TwoNameError(NIL, fname, pname, "function parameter must be available at return") :- AvailableParameterDemand(fname, pname), UnavailableParameterSupply(fname, pname).

	// The following checks are performed when there is no implementation, test decl.
	err.OneNameError(NIL, inName, "constructor arguments of the exported interface does not match constructor argument of creator interface") 
	:- MachineExports(_, inName), MachineCreatesInt(_, ic), InterfaceTypeDecl(iName, evL, t), InterfaceTypeDecl(ic, evL, t'), t != t', 
	no ImplementationDecl(_, _), no TestDecl(_, _, _), no RefinementDecl(_, _, _, _).

	err.OneNameError(NIL, ic, "created interface is not exported by any machine") 
	:- MachineDecl(mach, _, _), no MachineExports(_, inName), MachineCreatesInt(mach, ic), InterfaceTypeDecl(iName, evL, t), InterfaceTypeDecl(ic, evL, t'), 
	no ImplementationDecl(_, _), no TestDecl(_, _, _), no RefinementDecl(_, _, _, _).

	err.TwoNameError(NIL, mach1, mach2, "two machines cannot export the same interface") 
	:- MachineExports(mach1, ix1), MachineExports(mach2, ix2), mach1 != mach2, InterfaceTypeDecl(ix2, evL, _), InterfaceTypeDecl(ix1, evL, _),
	no ImplementationDecl(_, _), no TestDecl(_, _, _), no RefinementDecl(_, _, _, _).

	/******************************************/
	/*   Module System related Linker Errors */
	/*****************************************/

	//// Check if the named module definition is legal ////
	ModuleDefError(modEx.id, name, "undefined module") :- AllModuleExprs(modEx), modEx = ModuleName(name, _), no ModuleDecl(name, _), no ModuleDef(name, _).

	ModuleDefError(expr1.id, modName, "multiple named module definitions with the same name") :- ModuleDef(modName, expr1), ModuleDef(modName, expr2), expr1 != expr2.

	ModuleDefDepends ::= sub (modDef: ModuleDef, mName: ModuleName).
	ModuleNameDepends ::= (name1: String, name2: String).
	ModuleNameDepends(nmodule.name, modName.name) :- ModuleDefDepends(nmodule, modName).
	ModuleNameDepends(name1, name3) :- ModuleNameDepends(name1, name2), ModuleNameDepends(name2, name3).

	ModuleDefError(NIL, name, "named module depends on itself") :- ModuleNameDepends(name, name).

	//// Expand ModuleExpr
	AllModuleExprs ::= sub (ModuleExpr).
	ModuleExprExpansion ::= (modExpr: ModuleExpr, eModExpr: ModuleExpr).
	
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr : ModuleName, emodExpr = ModuleDecl(modExpr.name, modExpr.id), no ModuleDef(modExpr.name, _).
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr : ModuleName, no ModuleDefError(_, modExpr.name, _), no ModuleDecl(modExpr.name, _), ModuleDef(modExpr.name, modExpr'), ModuleExprExpansion(modExpr', emodExpr).
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = ModuleDecl(name, id), emodExpr = ModuleDecl(name, id).
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = HideExpr(s, modExpr', id), emodExpr = HideExpr(s, emodExpr', id),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = RenameExpr(s1, s2, modExpr', id), emodExpr = RenameExpr(s1, s2, emodExpr', id),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = ExportExpr(s1, s2, modExpr', id), emodExpr = ExportExpr(s1, s2, emodExpr', id),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = AssumeExpr(s, modExpr', id), emodExpr = AssumeExpr(s, emodExpr', id),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = AssertExpr(s, modExpr', id), emodExpr = AssertExpr(s, emodExpr', id),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = SafeExpr(modExpr', id), emodExpr = SafeExpr(emodExpr', id),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = ComposeExpr(modExpr', modExpr'', id), emodExpr = ComposeExpr(emodExpr', emodExpr'', id), ModuleExprExpansion(modExpr', emodExpr'), ModuleExprExpansion(modExpr'', emodExpr'').

	//// All expanded Module Exprs
	AllExpandedModuleExprs ::= (modExpr: ModuleExpr).
	AllExpandedModuleExprs(emodExpr) :- AllModuleExprs(modExpr), ModuleExprExpansion(modExpr, emodExpr).

	//// All leaf modules in module expr
	AllModuleDecls ::= (modExpr: ModuleExpr, mod: ModuleDecl).
	AllModuleDecls(modExpr, mod) :- AllExpandedModuleExprs(modExpr), toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #ModuleDecl, AllModuleDecls(modExpr.mod, mod).
	AllModuleDecls(modExpr, mod) :- AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, mod = modExpr.
	AllModuleDecls(modExpr, mod) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, AllModuleDecls(modExpr.left, mod);
									AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, AllModuleDecls(modExpr.right, mod).
	

	/**************************************************************************/
	/*	Check that there is main machine in each moduleExpr in the test decl  */
	/**************************************************************************/
	NoMainMachineInModExpr(id, "no Main machine in the module expression in test decl") :-
			TestDecl(_, modExpr, id), ModuleExprExpansion(modExpr, emodExpr), no ModuleRenameMap(emodExpr, "Main", _);
			RefinementDecl(_, modExpr, _, id), ModuleExprExpansion(modExpr, emodExpr), no ModuleRenameMap(emodExpr, "Main", _);
			RefinementDecl(_, _, modExpr, id), ModuleExprExpansion(modExpr, emodExpr), no ModuleRenameMap(emodExpr, "Main", _).

	/************************************************************************************/
	/*	Generate sends, receives, exports, private and creates for Module Expressions   */
	/************************************************************************************/
	
	//// Compute the private set for leaf module
	ModulePrivate(mod, ev.name) :- mod is ModuleDecl, ModulePrivateEvents(mod, NIL), ev is EventDecl.

	//// private events 
	ModulePrivate(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, ModulePrivateEvents(modExpr, ev), ev : in.NonNullEventName;
								  AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, ModulePrivateEvents(modExpr, NIL), ModuleContains(ModuleDecl(modExpr.name, _), mach), MachineReceives(mach, ev).
	ModulePrivate(modExpr, ev) :- AllExpandedModuleExprs(modExpr), toSymbol(modExpr) != #HideExpr, toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #ModuleDecl, ModulePrivate(modExpr.mod, ev).
	ModulePrivate(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : HideExpr, ModulePrivate(modExpr.mod, ev), ev: in.NonNullEventName;
								  AllExpandedModuleExprs(modExpr), modExpr : HideExpr, MemberOfEventNameList(modExpr.evtNames, ev), ev: in.NonNullEventName.
	ModulePrivate(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModulePrivate(modExpr.left, ev);
								  AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModulePrivate(modExpr.right, ev).
									 
	//// sends list 
	ModuleSends(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, MachineSends(mach, ev), ModuleContains(ModuleDecl(modExpr.name, _), mach), no ModulePrivate(modExpr, ev). 
	ModuleSends(modExpr, ev) :- AllExpandedModuleExprs(modExpr), toSymbol(modExpr) != #HideExpr, toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #ModuleDecl, ModuleSends(modExpr.mod, ev).
	ModuleSends(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModuleSends(modExpr.left, ev);
								AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModuleSends(modExpr.right, ev).
	ModuleSends(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : HideExpr, MachineSends(_, ev), ModuleSends(modExpr.mod, ev), no MemberOfEventNameList(modExpr.evtNames, ev).
	
	//// exports list
	AllExportedInterfaces ::= (ix: String).
	AllExportedInterfaces(ix) :-  ExportExpr(_, ix, _, _); MachineExports(_, ix).
	ModuleExports(modExpr, ix) :- AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, MachineExports(mach, ix), ModuleContains(ModuleDecl(modExpr.name, _), mach).
	ModuleExports(modExpr, ix) :- AllExpandedModuleExprs(modExpr), ModuleExports(modExpr.mod, ix),
										 toSymbol(modExpr) != #HideExpr, toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #ModuleDecl, toSymbol(modExpr) != #ExportExpr.
	ModuleExports(modExpr, ix) :- AllExpandedModuleExprs(modExpr), modExpr : ExportExpr, ModuleExports(modExpr.mod, ix);
								  AllExpandedModuleExprs(modExpr), modExpr : ExportExpr, ix = modExpr.iName.
	ModuleExports(modExpr, ix) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModuleExports(modExpr.left, ix);
								  AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModuleExports(modExpr.right, ix).									 
	ModuleExports(modExpr, ix) :- AllExpandedModuleExprs(modExpr), modExpr : HideExpr, AllExportedInterfaces(ix), ModuleExports(modExpr.mod, ix), InterfaceTypeDecl(ix, es, _), count({ev | MemberOfEventNameList(es, ev), MemberOfEventNameList(modExpr.evtNames, ev)}) = 0.

	//// creates list
	AllCreatedInterfaces ::= (ic: String).
	AllCreatedInterfaces(ic) :- MachineCreatesInt(_, ic).
	ModuleCreates(modExpr, ic) :- AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, MachineCreatesInt(mach, ic), ModuleContains(ModuleDecl(modExpr.name, _), mach).
	ModuleCreates(modExpr, ic) :- AllExpandedModuleExprs(modExpr), ModuleCreates(modExpr.mod, ic),
										 toSymbol(modExpr) != #HideExpr, toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #ModuleDecl.
	ModuleCreates(modExpr, ic) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModuleCreates(modExpr.left, ic);
									     AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModuleCreates(modExpr.right, ic).									 
	ModuleCreates(modExpr, ic) :- AllExpandedModuleExprs(modExpr), modExpr : HideExpr, AllCreatedInterfaces(ic), ModuleCreates(modExpr.mod, ic), InterfaceTypeDecl(ic, es, _), count({ev | MemberOfEventNameList(es, ev), MemberOfEventNameList(modExpr.evtNames, ev)}) = 0.

	//// receives list
	ModuleReceives(modExpr, er) :- AllExpandedModuleExprs(modExpr), ModuleExports(modExpr, ix), InterfaceTypeDecl(ix, es, _), MemberOfEventNameList(es, er), er : in.NonNullEventName.

	/**************************************************************************/
	/**				Check that the module contruction is legal			  	  */
	/**************************************************************************/

	//// Export Operation 1 (m \in M)
	ModuleConstructionIllegal(id, m, "exported machine undefined in the module expression") 
	:- AllExpandedModuleExprs(modExpr), modExpr = ExportExpr(m, ix, mod, id), no ModuleRenameMap(mod, m, _).

	//// Export Operation 2 (\alpha not empty and is defined)
	ModuleConstructionIllegal(id, ix, "exported interface not declared") 
	:- AllExpandedModuleExprs(modExpr), modExpr = ExportExpr(m, ix, _, id), no InterfaceTypeDecl(ix, _, _).

	//// Export Operation 3 (\alpha = MR(m)\EP)
	ModuleConstructionIllegal(id, ix, "interface exported is not equal to the interface implemented by machine") 
	:- AllExpandedModuleExprs(modExpr), modExpr = ExportExpr(m, ix, mod, id), ModuleRenameMap(mod, m, mach), 
	impInterface = toList(#InterfaceType, NIL, {ev | MachineReceives(mach, ev), no ModulePrivate(mod, ev)}), InterfaceTypeDecl(ix, exInterface, _), exInterface != impInterface.

	//// Export Operation 4 (constructor type match)
	ModuleConstructionIllegal(id, ix, "exported interface constructor type is not equal to the contructor type of implemented machine") 
	:- AllExpandedModuleExprs(modExpr), modExpr = ExportExpr(m, ix, mod, id), ModuleRenameMap(mod, m, mach), InterfaceTypeDecl(ix, _, iargt), MachineDecl(mach, ct, _), iargt != ct.

	//// Export Operation 5 (\alpha is disjoint to all dom(IX))
	ModuleConstructionIllegal(id, ix, "interface being exported is not disjoint from the interfaces already exported by the module expression") 
	:-	AllExpandedModuleExprs(modExpr), modExpr = ExportExpr(m, ix, mod, id), ModuleExports(mod, ix'), 
		InterfaceTypeDecl(ix, eIx, _), InterfaceTypeDecl(ix', eIx', _), eIx = eIx';
		AllExpandedModuleExprs(modExpr), modExpr = ExportExpr(m, ix, mod, id), ModuleExports(mod, ix'), 
		InterfaceTypeDecl(ix, el, _), InterfaceTypeDecl(ix', el', _), MemberOfEventNameList(el, ev), MemberOfEventNameList(el', ev).

	/// Export Operation 6 (\alpha is disjoint or equal to all IC)
	ModuleConstructionIllegal(id, ix, "interface being exported is not disjoint or equal to the interfaces created by the module expression") 
	:-	AllExpandedModuleExprs(modExpr), modExpr = ExportExpr(m, ix, mod, id), ModuleCreates(mod, ic), 
		InterfaceTypeDecl(ix, eIx, _), InterfaceTypeDecl(ic, eIc, _), eIx != eIc, 
		InterfaceTypeDecl(ix, el, _), InterfaceTypeDecl(ic, el', _), MemberOfEventNameList(el, ev), MemberOfEventNameList(el', ev).
									
	/// Export Operation 7 (permissions in mod-expression is disjoint from \alpha )
	ModuleConstructionIllegal(id, ix, "after hidding the public events in receives or sends have private permission in them") 
	:- AllExpandedModuleExprs(modExpr), modExpr = ExportExpr(m, ix, mod, id), InterfaceTypeDecl(ix, el, _), MemberOfEventNameList(el, ev), PermEmbeddedInEvent(pt, perm), ModulePrivate(modExpr, perm).


	////Rename Operation
	//check if the names in rename exists
	ModuleConstructionIllegal(id, newName, "new machine name already exists in the module expression") 
	:- AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldName, newName, mod, id), ModuleRenameMap(mod, newName, _);
	AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldName, newName, mod, id), ModuleRenameMap(mod, _, newName).

	ModuleConstructionIllegal(id, oldName, "machine being renamed does not exists in the module expression") 
	:- AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldName, _, mod, id), no ModuleRenameMap(mod, oldName, _).

	////Assume and Assert Operation
	//Monitor is defined
	ModuleConstructionIllegal(id, mon, "undefined monitor") 
	:- AllExpandedModuleExprs(modExpr), modExpr = AssumeExpr(monNames, _, id), MemberOfMonitorNameList(monNames, mon), no MonitorDecl(mon, _, _);
		AllExpandedModuleExprs(modExpr), modExpr = AssertExpr(monNames, _, id), MemberOfMonitorNameList(monNames, mon), no MonitorDecl(mon, _, _).
	
	//Events observed by monitor must be in ES or EP
	ModuleConstructionIllegal(id, mon, "monitors observes list contains an event that is not sends or private events of the module expression") 
	:- AllExpandedModuleExprs(modExpr), modExpr = AssumeExpr(monNames, mod, id), MemberOfMonitorNameList(monNames, mon), MonitorDecl(mon, obsList, _), MemberOfEventNameList(obsList, ev),
		no ModuleSends(mod, ev), no ModulePrivate(mod, ev);
		AllExpandedModuleExprs(modExpr), modExpr = AssertExpr(monNames, mod, id), MemberOfMonitorNameList(monNames, mon), MonitorDecl(mon, obsList, _), MemberOfEventNameList(obsList, ev),
		no ModuleSends(mod, ev), no ModulePrivate(mod, ev).


	//Hide Operation
	//make sure that the events is declared
	ModuleConstructionIllegal(id, ev, "undeclared event in hide operation") 
	:- AllExpandedModuleExprs(modExpr), modExpr = HideExpr(evtList, mod, id), MemberOfEventNameList(evtList, ev), no EventDecl(ev, _, _), ev: String.

	//alpha is disjoint from EP
	ModuleConstructionIllegal(id, ev, "trying to hide private event of the module expression") 
	:- AllExpandedModuleExprs(modExpr), modExpr = HideExpr(evtList, mod, id), ModulePrivate(mod, ev), MemberOfEventNameList(evtList, ev).

	//for each interface in dom(IX) and IC it is either disjoint from alpha or included in it.
	ModuleConstructionIllegal(id, ix1, "trying to partially hide an exported interface of the module expression") 
	:- AllExpandedModuleExprs(modExpr), modExpr = HideExpr(evtList, mod, id), ModuleExports(mod, ix1), InterfaceTypeDecl(ix1, el, _), MemberOfEventNameList(el, ev1), MemberOfEventNameList(evtList, ev1), MemberOfEventNameList(el, ev2), no MemberOfEventNameList(evtList, ev2).

	ModuleConstructionIllegal(id, ic, "trying to partially hide an interface created by the module expression") 
	:- AllExpandedModuleExprs(modExpr), modExpr = HideExpr(evtList, mod, id), ModuleCreates(mod, ic), InterfaceTypeDecl(ic, el, _), MemberOfEventNameList(el, ev1), 
		MemberOfEventNameList(evtList, ev1), MemberOfEventNameList(el, ev2), no MemberOfEventNameList(evtList, ev2).

	/// (permissions in ER + ES is disjoint from EP )
	ModuleConstructionIllegal(id, ev, "after hidding the event has private permission in them") 
	:- AllExpandedModuleExprs(modExpr), modExpr = HideExpr(evtList, mod, id), ModuleSends(modExpr, ev), PermEmbeddedInEvent(ev, perm), ModulePrivate(modExpr, perm);
		AllExpandedModuleExprs(modExpr), modExpr = HideExpr(evtList, mod, id), ModuleReceives(modExpr, ev), PermEmbeddedInEvent(ev, perm), ModulePrivate(modExpr, perm).

	//// trying to hide an interface in IC that is not in IX
	ModuleConstructionIllegal(id, ev, "illegal hiding of a created interface that is not exported by the module expression") 
	:- AllExpandedModuleExprs(modExpr), modExpr = HideExpr(evtList, mod, id), ModuleCreates(mod, ic), InterfaceTypeDecl(ic, el, _), MemberOfEventNameList(el, ev), ev: in.NonNullEventName,
	 MemberOfEventNameList(evtList, ev), no ModuleExports(mod, ix),  InterfaceTypeDecl(ix, el, _).


	//// LEGAL COMPOSITION !

	///// All composition expressions
	AllCompositionExprs ::= (modL: ModuleExpr, modR: ModuleExpr, emodL: ModuleExpr, emodR: ModuleExpr).
	AllCompositionExprs(modL, modR, emodL, emodR) :- AllModuleExprs(modExpr), modExpr = ComposeExpr(modL, modR, _), ModuleExprExpansion(modL, emodL), ModuleExprExpansion(modR, emodR).
	//// Mp and Mq are disjoint
	ModuleConstructionIllegal(modL.id, mname, "compatibility error> machine names are not disjoint") 
	:- AllCompositionExprs(modL, modR, emodL, emodR), ModuleRenameMap(emodL, mname, _), ModuleRenameMap(emodR, mname, _).

	//// dom(IXp) and dom(IXq) are disjoint
	ModuleConstructionIllegal(modL.id, ixL, "compatibility error> exported interfaces are not disjoint") 
	:- AllCompositionExprs(modL, modR, emodL, emodR), ModuleExports(emodL, ixL), ModuleExports(emodR, ixR), 
	InterfaceTypeDecl(ixL, esL, _), MemberOfEventNameList(esL, ev), InterfaceTypeDecl(ixR, esR, _), MemberOfEventNameList(esR, ev).									

	//// ICp and ICq are disjoint
	ModuleConstructionIllegal(modL.id, icL, "compatibility error> created interfaces are not disjoint") 
	:- AllCompositionExprs(modL, modR, emodL, emodR), ModuleCreates(emodL, icL), ModuleCreates(emodR, icR), 
		InterfaceTypeDecl(icL, esL, _), MemberOfEventNameList(esL, ev), InterfaceTypeDecl(icR, esR, _), MemberOfEventNameList(esR, ev).

	//// ESp and ESq are disjoint
	ModuleConstructionIllegal(modL.id, ev, "compatibility error> sends are not disjoint") 
	:- AllCompositionExprs(modL, modR, emodL, emodR), ModuleSends(emodL, ev), ModuleSends(emodR, ev).

	//// ES and EP are disjoint
	ModuleConstructionIllegal(modL.id, ev, "compatibility error> sends and privates are not disjoint") 
	:- AllCompositionExprs(modL, modR, emodL, emodR), ModuleSends(emodL, ev), ModulePrivate(emodR, ev);	
	AllCompositionExprs(modL, modR, emodL, emodR), ModuleSends(emodR, ev), ModulePrivate(emodL, ev).

	//// e \in ER + ES, all a in A(e) is disjoint from EP
	ModuleConstructionIllegal(modL.id, ev, "compatibility error> after composition the public events in receives or sends has private permissions in them") 
	:- AllCompositionExprs(modL, modR, emodL, emodR), composedMod = ComposeExpr(emodL, emodR, _), ModuleReceives(composedMod, ev),
	PermEmbeddedInEvent(ev, perm), ModulePrivate(composedMod, perm);
	AllCompositionExprs(modL, modR, emodL, emodR), composedMod = ComposeExpr(emodL, emodR, _), ModuleSends(composedMod, ev),
	PermEmbeddedInEvent(ev, perm), ModulePrivate(composedMod, perm).

	//// IX of the composed module is disjoint from EP of the composed module
	ModuleConstructionIllegal(modL.id, ix, "compatibility error> after composition the exported interfaces are not disjoint from the private events") 
	:- AllCompositionExprs(modL, modR, emodL, emodR), composedMod = ComposeExpr(emodL, emodR, _), ModuleExports(composedMod, ix),
	InterfaceTypeDecl(ix, es, _), MemberOfEventNameList(es, ev), ModulePrivate(composedMod, ev).

	//// IC of the composed module is disjoint from EP of the composed module
	ModuleConstructionIllegal(modL.id, ic, "compatibility error> after composition the created interfaces are not disjoint from the private events") 
	:- AllCompositionExprs(modL, modR, emodL, emodR), composedMod = ComposeExpr(emodL, emodR, _), ModuleCreates(composedMod, ic),
	InterfaceTypeDecl(ic, es, _), MemberOfEventNameList(es, ev), ModulePrivate(composedMod, ev).	

	//// IC is either disjoint or equal to the IX
	ModuleConstructionIllegal(modL.id, ix, "compatibility error> after composition the created interfaces are not disjoint or equal to the exported interfaces") 
	:- AllCompositionExprs(modL, modR, emodL, emodR), composedMod = ComposeExpr(emodL, emodR, _), ModuleCreates(composedMod, ic),
	ModuleExports(composedMod, ix), InterfaceTypeDecl(ic, icL, _), InterfaceTypeDecl(ix, ixL, _), icL != ixL,
	InterfaceTypeDecl(ic, esc, _), MemberOfEventNameList(esc, ev), InterfaceTypeDecl(ix, esx, _), MemberOfEventNameList(esx, ev).

	//// for the match IC and IX, constructor(IC) subtype of constructor(IX).
	ModuleConstructionIllegal(modL.id, ix, "compatibility error> after composition the constructor type of created interfaces is not a subtype of constructor type of exported interfaces") 
	:- AllCompositionExprs(modL, modR, emodL, emodR), composedMod = ComposeExpr(emodL, emodR, _), ModuleCreates(composedMod, ic),
	ModuleExports(composedMod, ix), InterfaceTypeDecl(ic, icL, _), InterfaceTypeDecl(ix, ixL, _), icL = ixL,
	InterfaceTypeDecl(ic, _, ct), InterfaceTypeDecl(ix, _, xt), ct != xt.
	
	//// make sure that the constructor arguments do not have private permissions in them.
	ModuleConstructionIllegal(modL.id, ic, "compatibility error> after composition the constructor type of created interface has private permissions") 
	:- AllCompositionExprs(modL, modR, emodL, emodR), composedMod = ComposeExpr(emodL, emodR, _), ModuleCreates(composedMod, ic),
	ModuleLinkMap(composedMod, _, ic, renameM), ModuleRenameMap(composedMod, renameM, impM), PermEmbeddedInConstType(impM, ev), ModulePrivate(composedMod, ev).
	
	/**************************************************************************/
	/*			Well-formedness condition check for the leaf modules		  */
	/**************************************************************************/
	
	//// machines mentioned in the module declaration are legal
	WellFormednessError(mod.id, mach, "wellformedness error> machine not defined")
	:- ModuleContains(mod, mach), mod: ModuleDecl, no MachineDecl(mach, _, _).

	//// events mentioned in the module declaration are legal
	WellFormednessError(mod.id, ev, "wellformedness error> event not defined")
	:- mod is ModuleDecl, ModulePrivateEvents(mod, ev), ev: NonNullEventName, no EventDecl(ev, _, _).

	//// make sure that new M in the module are for private machines.
	WellFormednessError(mod.id, mach, "wellformedness error> created machine using new M, but not all its events are private")
	:- mod is ModuleDecl, ModuleContains(mod, mach), MachineCreatesM(mach, newM), MachineCreatesM(mach, newM), MachineReceives(newM, ev), no ModulePrivate(mod, ev).

	//// ix is not disjoint from EP
	WellFormednessError(mod.id, ix, "wellformedness error> the exported interfaces are not disjoint from private events") 
	:- mod is ModuleDecl, ModuleExports(mod, ix), ModulePrivate(mod, ev), InterfaceTypeDecl(ix, es, _), MemberOfEventNameList(es, ev).

	//// ic is not disjoint from EP
	WellFormednessError(mod.id, ic, "wellformedness error> the created interfaces are not disjoint from private events") 
	:- mod is ModuleDecl, ModuleCreates(mod, ic), ModulePrivate(mod, ev), InterfaceTypeDecl(ic, es, _), MemberOfEventNameList(es, ev).

	//// IC is either disjoint or equal to the IX
	WellFormednessError(mod.id, ix, "wellformedness error> the created interfaces are not disjoint or equal to the exported interface") 
	:- mod is ModuleDecl, ModuleCreates(mod, ic), ModuleExports(mod, ix), InterfaceTypeDecl(ic, icL, _), InterfaceTypeDecl(ix, ixL, _), 									
	icL != ixL, InterfaceTypeDecl(ic, esc, _), MemberOfEventNameList(esc, ev), InterfaceTypeDecl(ix, esx, _), MemberOfEventNameList(esx, ev).

	//// for the match IC and IX, constructor(IC) subtype of constructor(IX).
	WellFormednessError(mod.id, ix, "wellformedness error> type of created interfaces is not a subtype of constructor type of exported interface") 
	:- mod is ModuleDecl, ModuleCreates(mod, ic), ModuleExports(mod, ix), 
	InterfaceTypeDecl(ic, icL, ct), InterfaceTypeDecl(ix, ixL, xt), icL = ixL, ct != xt.

	//// e \in ER + ES, all a in A(e) is disjoint from EP
	WellFormednessError(mod.id, ev, "wellformedness error> the public events in receives or sends has private permissions in them") 
	:- mod is ModuleDecl, ModuleReceives(mod, ev), PermEmbeddedInEvent(ev, perm), ModulePrivate(mod, perm);
	mod is ModuleDecl, ModuleSends(mod, ev), PermEmbeddedInEvent(ev, perm), ModulePrivate(mod, perm).

	//// no two machines export the same interface
	WellFormednessError(mod.id, ix, "wellformedness error> multiple machines export the same interface") 
	:- mod is ModuleDecl, ModuleContains(mod, mach), ModuleContains(mod, mach'), MachineExports(mach, ix), MachineExports(mach', ix'),
	InterfaceTypeDecl(ix, ixL, _), InterfaceTypeDecl(ix', ixL, _), mach != mach'.

	//// private machines created by a module are part of the module.
	WellFormednessError(mod.id, mach, "wellformedness error> created machine using new M is not included in the module")
	:- mod is ModuleDecl, ModuleContains(mod, mach), MachineCreatesM(mach, newM), no ModuleContains(mod, newM).

	/**************************************************************************/
	/*			Refinement, Implementation and Test Decls are legal			  */
	/**************************************************************************/

	////Implementation and test module expr must be closed with respect to creates
	TestOrImplDeclError(modExpr.id, ic, "top level module expressions must be closed with respect to created interfaces (all created interfaces must be exported)") 
	:- ImplementationDecl(modExpr, _), ModuleExprExpansion(modExpr, emodExpr), ModuleCreates(emodExpr, ic), no ModuleExports(emodExpr, ix),InterfaceTypeDecl(ic, x, _), InterfaceTypeDecl(ix, x, _);
	TestDecl(_, modExpr, _), ModuleExprExpansion(modExpr, emodExpr), ModuleCreates(emodExpr, ic), no ModuleExports(emodExpr, ix), InterfaceTypeDecl(ic, x, _), InterfaceTypeDecl(ix, x, _);
	RefinementDecl(_, modExpr, _, _), ModuleExprExpansion(modExpr, emodExpr), ModuleCreates(emodExpr, ic), no ModuleExports(emodExpr, ix), InterfaceTypeDecl(ic, x, _), InterfaceTypeDecl(ix, x, _);
	RefinementDecl(_, _, modExpr, _), ModuleExprExpansion(modExpr, emodExpr), ModuleCreates(emodExpr, ic), no ModuleExports(emodExpr, ix), InterfaceTypeDecl(ic, x, _), InterfaceTypeDecl(ix, x, _).

	//// There is only one implementation modExpr
	TestOrImplDeclError(modExpr.id, "Error", "Multiple implementation declarations")
	:- ImplementationDecl(modExpr, _), ImplementationDecl(modExpr', _), modExpr != modExpr'.

	//// Refinement checks
	AllRefinementTests ::= (modL: ModuleExpr, modR: ModuleExpr).
	AllRefinementTests(emodL, emodR) :- RefinementDecl(_, modL, modR, _), ModuleExprExpansion(modL, emodL), ModuleExprExpansion(modR, emodR).

	// IC_q subset of IC_p
	RefinementDeclError(modp.id, icq, "interfaces created by RHS must be a subset of interfaces created by LHS") :-
	AllRefinementTests(modp, modq), ModuleCreates(modq, icq), InterfaceTypeDecl(icq, icL, _), no ModuleCreates(modp, icp), InterfaceTypeDecl(icp, icL, _).
	
	// IXq subset of iXp U ICp
	RefinementDeclError(modp.id, ixq, "interfaces implemented by RHS must be a subset of interfaces implemented + created by LHS") :-
	AllRefinementTests(modp, modq), ModuleExports(modq, ixq), InterfaceTypeDecl(ixq, ixL, _), no ModuleCreates(modp, icp), InterfaceTypeDecl(icp, ixL, _), no ModuleExports(modp, ixp), InterfaceTypeDecl(ixp, ixL, _).

	// ESq subset of ESp
	RefinementDeclError(modp.id, ev, "events sent by RHS must be subset of events sents by LHS") :-
	AllRefinementTests(modp, modq), ModuleSends(modq, ev), no ModuleSends(modp, ev).

	// ERq subset of ERp U ESp
	RefinementDeclError(modp.id, ev, "events received by RHS must be subset of events sent or received by LHS") :-
	AllRefinementTests(modp, modq), ModuleReceives(modq, ev), no ModuleSends(modp, ev), no ModuleReceives(modp, ev).


	/**************************************************************************/
	/*			Populate all the maps used for code generation				  */
	/**************************************************************************/
	
	////populate the rename map
	ModuleRenameMap(modExpr, newName, impName) :-	AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, ModuleContains(ModuleDecl(modExpr.name, _), newName), newName = impName.
	ModuleRenameMap(modExpr, newName, impName) :-	AllExpandedModuleExprs(modExpr), modExpr : SafeExpr, ModuleRenameMap(modExpr.mod, newName, impName);
													AllExpandedModuleExprs(modExpr), modExpr : HideExpr, ModuleRenameMap(modExpr.mod, newName, impName);
													AllExpandedModuleExprs(modExpr), modExpr : ExportExpr, ModuleRenameMap(modExpr.mod, newName, impName).
	ModuleRenameMap(modExpr, newName, impName) :-	AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModuleRenameMap(modExpr.left, newName, impName);
													AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModuleRenameMap(modExpr.right, newName, impName).	
	ModuleRenameMap(modExpr, newName, impName) :-	AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldname, _, modExpr', _), ModuleRenameMap(modExpr', newName, impName), newName != oldname;
													AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldname, newName, modExpr', _), ModuleRenameMap(modExpr', oldname, impName).
	ModuleRenameMap(modExpr, newName, impName) :-	AllExpandedModuleExprs(modExpr), modExpr = AssumeExpr(monNames, modExpr', _), ModuleRenameMap(modExpr', newName, impName);
													AllExpandedModuleExprs(modExpr), modExpr = AssumeExpr(monNames, modExpr', _), MemberOfMonitorNameList(monNames, newName), MonitorDecl(newName, _, _), impName = newName.
	ModuleRenameMap(modExpr, newName, impName) :-	AllExpandedModuleExprs(modExpr), modExpr = AssertExpr(monNames, modExpr', _), ModuleRenameMap(modExpr', newName, impName);
													AllExpandedModuleExprs(modExpr), modExpr = AssertExpr(monNames, modExpr', _), MemberOfMonitorNameList(monNames, newName),  MonitorDecl(newName, _, _), impName = newName.										 										 								 							 
	////populate the safe map
	ModuleSafeMap(modExpr, mname, isSafe) :- AllExpandedModuleExprs(modExpr), toSymbol(modExpr) != #SafeExpr, toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #AssertExpr, 
											  toSymbol(modExpr) != #AssumeExpr, toSymbol(modExpr) != #ModuleDecl, toSymbol(modExpr) != #RenameExpr, ModuleSafeMap(modExpr.mod, mname, isSafe).
	ModuleSafeMap(modExpr, mname, FALSE) :-  AllExpandedModuleExprs(modExpr), modExpr : ModuleExpr, ModuleRenameMap(modExpr, mname, _).
	ModuleSafeMap(modExpr, mname, isSafe) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModuleSafeMap(modExpr.left, mname, isSafe);
											 AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModuleSafeMap(modExpr.right, mname, isSafe).
	ModuleSafeMap(modExpr, mname, isSafe) :- AllExpandedModuleExprs(modExpr), modExpr : AssumeExpr, ModuleSafeMap(modExpr.mod, mname, isSafe);
											 AllExpandedModuleExprs(modExpr), modExpr = AssumeExpr(monNames, modExpr', _), MemberOfMonitorNameList(monNames, mname), MonitorDecl(mname, _, _), isSafe = TRUE.
	ModuleSafeMap(modExpr, mname, isSafe) :- AllExpandedModuleExprs(modExpr), modExpr = AssertExpr(monNames, modExpr', _), ModuleSafeMap(modExpr.mod, mname, isSafe);
											 AllExpandedModuleExprs(modExpr), modExpr = AssertExpr(monNames, modExpr', _), MemberOfMonitorNameList(monNames, mname), MonitorDecl(mname, _, _), isSafe = FALSE.
	ModuleSafeMap(modExpr, mname, TRUE) :-	 AllExpandedModuleExprs(modExpr), modExpr : SafeExpr, ModuleSafeMap(modExpr.mod, mname, _).
	ModuleSafeMap(modExpr, mname, isSafe) :- AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldname, _, modExpr',_), ModuleSafeMap(modExpr', mname, isSafe), mname != oldname;
											 AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldname, newname, modExpr',_), ModuleSafeMap(modExpr', mname', isSafe), mname' = oldname, mname = newname.

	////populate the monitor map
	ModuleMonitorMap(modExpr, monName, impMachine) :- AllExpandedModuleExprs(modExpr), toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #AssumeExpr, toSymbol(modExpr) != #AssertExpr, 
													  toSymbol(modExpr) != #RenameExpr, ModuleMonitorMap(modExpr.mod, monName, impMachine).
	ModuleMonitorMap(modExpr, monName, impMachine) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModuleMonitorMap(modExpr.left, monName, impMachine);
													  AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModuleMonitorMap(modExpr.right, monName, impMachine).
	ModuleMonitorMap(modExpr, monName, impMachine) :- AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldname, _, modExpr', _), ModuleMonitorMap(modExpr', monName, impMachine), monName != oldname;
											 		  AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldname, newname, modExpr', _), ModuleMonitorMap(modExpr', monName', impMachine), monName' = oldname, monName = newname;
											 		  AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldname, newname, modExpr', _), ModuleMonitorMap(modExpr', monName, impMachine'), impMachine' = oldname, impMachine = newname.	
	ModuleMonitorMap(modExpr, monName, impMachine) :- AllExpandedModuleExprs(modExpr), modExpr : AssumeExpr, MemberOfMonitorNameList(modExpr.monNames, monName), ModuleLinkMap(modExpr.mod, impMachine, _, _).
	ModuleMonitorMap(modExpr, monName, impMachine) :- AllExpandedModuleExprs(modExpr), modExpr : AssertExpr, MemberOfMonitorNameList(modExpr.monNames, monName), ModuleLinkMap(modExpr.mod, impMachine, _, _).

	////populate the link map
	ModuleLinkMap(modExpr, creatorM, IorM, ImpMachine) :- AllExpandedModuleExprs(modExpr), toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #RenameExpr, toSymbol(modExpr) != #ModuleDecl,
													  toSymbol(modExpr) != #ExportExpr, ModuleLinkMap(modExpr.mod, creatorM, IorM, ImpMachine).

	ModuleLinkMap(modExpr, creatorM, IorM, ImpMachine) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModuleLinkMap(modExpr.left, creatorM, IorM, ImpMachine);
														  AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModuleLinkMap(modExpr.right, creatorM, IorM, ImpMachine);
														  AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModuleLinkMap(modExpr.left, creatorM, _, _), ModuleLinkMap(modExpr.right, _, IorM, ImpMachine), ModuleExports(modExpr.right, IorM);
														  AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ModuleLinkMap(modExpr.right, creatorM, _, _), ModuleLinkMap(modExpr.left, _, IorM, ImpMachine), ModuleExports(modExpr.left, IorM).


	ModuleLinkMap(modExpr, creatorM, IorM, ImpMachine) :- AllExpandedModuleExprs(modExpr), modExpr : ExportExpr, ModuleLinkMap(modExpr.mod, creatorM, IorM, ImpMachine);
													  	  AllExpandedModuleExprs(modExpr), modExpr : ExportExpr, ModuleLinkMap(modExpr.mod, creatorM, _, _), IorM = modExpr.iName, ImpMachine = modExpr.mName.
	ModuleLinkMap(modExpr, creatorM, IorM, ImpMachine) :- AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldname, _, modExpr', _), ModuleLinkMap(modExpr', creatorM, IorM, ImpMachine), creatorM != oldname, ImpMachine != oldname;
														AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldname, newname, modExpr',_), ModuleLinkMap(modExpr', creatorM', IorM, ImpMachine), creatorM' = oldname, creatorM = newname, ImpMachine != oldname;
													  	AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldname, newname, modExpr', _), ModuleLinkMap(modExpr', creatorM, IorM, ImpMachine'), ImpMachine' = oldname, ImpMachine = newname, creatorM != oldname;
													  	AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldname, newname, modExpr', _), ModuleLinkMap(modExpr', creatorM', IorM, ImpMachine'), ImpMachine' = oldname, creatorM' = oldname, creatorM = newname, ImpMachine = newname.

	ModuleLinkMap(modExpr, creatorM, IorM, ImpMachine) :- AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, ModuleContains(ModuleDecl(modExpr.name, _), creatorM), MachineCreatesM(creatorM, ImpMachine), IorM =  ImpMachine;
														  AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, ModuleContains(ModuleDecl(modExpr.name, _), creatorM), ModuleExports(modExpr, IorM), MachineExports(ImpMachine, IorM);
														  AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, ModuleContains(ModuleDecl(modExpr.name, _), creatorM), IorM = NIL, ImpMachine = NIL.
	
	CSharpLinkMap(testName, MachineName, interfaceOrMachine, ImpMachine) :- TestDecl(testName, modExpr, _), ModuleLinkMap(modExpr, MachineName, interfaceOrMachine, ImpMachine), interfaceOrMachine: String, ImpMachine: String.
	CSharpRenameMap(testName, newName, impName) :- TestDecl(testName, modExpr, _), ModuleRenameMap(modExpr, newName, impName).
	CSharpSafeMap(testName, mname, isSafe):- TestDecl(testName, modExpr, _), ModuleSafeMap(modExpr, mname, isSafe).
	CSharpMonitorMap(testName, monName, impMachine) :- TestDecl(testName, modExpr, _), ModuleMonitorMap(modExpr, monName, impMachine).

	//If there is no testdecl then generate linkmap corresponding to CLinkMap
	CSharpRenameMap("output", newName, impName) :- no TestDecl(_, _, _), CRenameMap (newName, impName).
	CSharpLinkMap("output", creatorM, IorM, impM) :- no TestDecl(_, _, _), CLinkMap(creatorM, IorM, impM).
	CSharpSafeMap("output", newName, FALSE) :- no TestDecl(_, _, _), CRenameMap (newName, _).

	/**************************************************************************/
	/*     C Code Helpers
	/**************************************************************************/

	//// Compute the link map for C code
	CLinkMap ::= (creatorM: String, IorM: String, impM: String).
	// make sure that the IorM matches the name of interface created by the machine (new I).
	// impM is the name of the real machine and not the renamed name.
	CLinkMap(creatorM, IorM, impM) :-	ImplementationDecl(modExpr, _), ModuleExprExpansion(modExpr, emodExpr), ModuleLinkMap(emodExpr, creatorM, cM, impM), no InterfaceTypeDecl(IorM, _, _), cM = IorM, cM : String, impM : String; //machine creation
										ImplementationDecl(modExpr, _), ModuleExprExpansion(modExpr, emodExpr), ModuleLinkMap(emodExpr, creatorM, IorM, impM), IorM : String, impM : String.
	
	CRenameMap ::= (nName: String, iName: String).
	CRenameMap(newName, ImpName) :- ImplementationDecl(modExpr, _), ModuleExprExpansion(modExpr, emodExpr), ModuleRenameMap(emodExpr, newName, ImpName).
	
	// If there is no implementation decl then generate the normal link map
	CLinkMap(creatorM, IorM, impM) :- MachineDecl(creatorM, _, _), MachineDecl(IorM, _, _), impM = IorM, no ImplementationDecl(_, _);
									  MachineDecl(creatorM, _, _), MachineCreatesInt(creatorM, IorM), MachineExports(impM, IorM), no ImplementationDecl(_, _).
	
	CRenameMap (nName, nName) :- MachineDecl(nName, _, _), no ImplementationDecl(_, _).


    /*************************************************************/
    /**********         Create Header File             ***********/
    /*************************************************************/
    //// Elements will be output to header file in order of position.
    HOut ::= (pos: Natural, cmp: out.Cmp).
    HOutOrder ::= (ord: Natural, cmp: out.Cmp).
	HOutOrder(o, cmp) :- ho is HOut(_, cmp), o = toOrdinal(ho, 0, { ho' | ho' is HOut }). 

    //// Concat elements in order.
	HConcatOut ::= (pos: Integer, cmp: out.Cmp).	
	HConcatOut(-1, NIL).
	HConcatOut(m', cmp) :- HConcatOut(m, before), HOutOrder(m', nxt), m' = m + 1, cmp = Section(before, nxt). 		
		
	out.File(headerFileName, body) :- HConcatOut(count({ho | ho is HOut}) - 1, cmp), 
								      headerFileName = "linker.h",
									  ifdefBegin = PpITE(IFDEF, Ident("__cplusplus"), PpEscape(Ident("extern \"C\"{")), NIL),
									  ifdefEnd = PpITE(IFDEF, Ident("__cplusplus"), PpEscape(Ident("}")), NIL),
									  body = PpITE(
									   IFNDEF,
									   Ident("P_LINKER_H"),
									   Section(
										   Section(
											  PpDefine(Ident("P_LINKER_H"), NIL),
											  Section(
											     PpInclude("PrtUser.h", FALSE),
											     PpInclude("PrtExecution.h", FALSE)											  
											  )),
										   Section(ifdefBegin, Section(cmp, ifdefEnd))),
									   NIL).

    /*************************************************************/
    /**********         Create Code File               ***********/
    /*************************************************************/
    //// Elements will be output to c file in order of position.
    COut ::= (pos: Natural, cmp: out.Cmp).
	COutOrder ::= (ord: Natural, cmp: out.Cmp).

    //// Concat elements in order.
	COutOrder(o, cmp) :- co is COut(_, cmp), o = toOrdinal(co, 0, { co' | co' is COut }). 
	CConcatOut ::= (pos: Integer, cmp: out.Cmp).	
	CConcatOut(-1, NIL).
	CConcatOut(m', cmp) :- CConcatOut(m, before), COutOrder(m', nxt), m' = m + 1, cmp = Section(before, nxt). 		
		
	out.File(codeFileName, body) :- CConcatOut(count({co | co is COut}) - 1, cmp),
	                               headerFileName = "linker.h",
								   codeFileName = "linker.c",
								   body = Section(PpInclude(headerFileName, FALSE), cmp).

	/*************************************************************/
    /**********   Generate contents of header file     ***********/
    /*************************************************************/
	
	EventDeclExt ::= EventDecl + { NULL, HALT }.
	DeclId ::= (decl: MachineDecl + EventDecl + FunDecl + AnonFunDecl + { NULL, HALT }, id: Natural, cname: String).
	
	//// Foreign types
	HOut(0, out.EnmDef(NIL, "P_FORGN_TYPES", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   ModelType(name), id = toOrdinal(name, 0, { n | ModelType(n) }), cn = strJoin("P_FORGN_TYPE_", name), enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_FORGN_TYPES_COUNT"), size = count({n | ModelType(n)}) }).  
	
	//// Field names for named tuple types that have a type synonym
	IndexOf ::= (t: NmdTupType, name: String, offset: Natural, tail: NmdTupType + {NIL}).
	IndexOf(t, name, 0, tail)  :- TypeDef(_, t), t = NmdTupType(NmdTupTypeField(name, _), tail).
	IndexOf(t, name, i', tail) :- IndexOf(t, _, i, tail'), tail' = NmdTupType(NmdTupTypeField(name, _), tail), i' = i + 1.

	HOut(0, out.EnmDef(NIL, enumName, list)) :- 
	   d is TypeDef(name, type), type: NmdTupType, enumName = strJoin("P_FIELD_INDEX_", name),
	   list = toList(#Elements, NIL, { enumMember | 
									   IndexOf(type, f, offset, _), cn = strJoin(strJoin(enumName, "_"), f), enumMember = Element(IntLit(offset, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), strJoin(strJoin("_", enumName), "_COUNT")), size = lstLength(#NmdTupType, type) }).  
	
	//// Enum declarations for all enum types
	EnumTypeElem ::= (EnumTypeDef, StringList, IntegerList + { NIL }).
	EnumTypeElem(d, list1, list2) :- d is EnumTypeDef(_, list1, list2).
	EnumTypeElem(d, list1, NIL) :- EnumTypeElem(d, StringList(_, list1), NIL), list1: StringList.
	EnumTypeElem(d, list1, list2) :- EnumTypeElem(d, StringList(_, list1), IntegerList(_, list2)), list1: StringList.

	EnumTypeElemIndex ::= (EnumTypeDef, StringList, IntegerList + { NIL }, String, Integer).
	EnumTypeElemIndex(d, list, NIL, str, i) :- EnumTypeElem(d, list, NIL), list = StringList(str, NIL), i = lstLength(#StringList, d.elems) - 1.
	EnumTypeElemIndex(d, list, NIL, str, i) :- EnumTypeElem(d, list, NIL), list = StringList(str, list'), 
											   EnumTypeElemIndex(d, list', NIL, _, j), i = j - 1.
  	EnumTypeElemIndex(d, list1, list2, str, i) :- EnumTypeElem(d, list1, list2), 
												  list1 = StringList(str, _), list2 = IntegerList(i, _).

	HOut(0, out.EnmDef(NIL, enumName, list)) :-
		d is EnumTypeDef(enumName, elems, _), size = lstLength(#StringList, elems),
		list = toList(#Elements, NIL, { enumMember | 
										EnumTypeElemIndex(d, _, _, name, offset), cn = strJoin(strJoin(enumName, "_"), name), enumMember = Element(IntLit(offset, DEC, NIL), cn);
										enumMember = Element(IntLit(size, DEC, NIL), strJoin(strJoin("_", enumName), "_COUNT")) }).  
	
	//// EventDecls - Id 0, 1 are reserved for null, halt event, which can appear in transition tables.
	DeclId(NULL, 0, "_P_EVENT_NULL").
	DeclId(HALT, 1, "_P_EVENT_HALT").
	DeclId(d, id, cn) :- d is EventDecl, id = 2 + toOrdinal(d, 0, { d' | d' is EventDecl }), cn = strJoin("P_EVENT_", d.name).
	
	HOut(0, out.EnmDef(NIL, "P_EVENTS", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   DeclId(d, id, cn), d : EventDeclExt, enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_EVENTS_COUNT"), size = 2 + count({d | d is EventDecl}) }).  
			
	//// MemberOfEventNameLists
	HOut(0, out.EnmDef(NIL, "P_EVENTSET", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   EventSet(evsetName, eventNameList), id = toOrdinal(eventNameList, 0, { x | EventSet(_, x) }), enumMember = Element(IntLit(id, DEC, NIL), evsetName); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_EVENTSETS_COUNT"), size = count({ x | x is EventSet }) }).  
	
	//// (Anon)FunDecls
	AnonOrNamedFun ::= FunDecl + AnonFunDecl.
	DeclId(d, id, cn) :- 
		d is FunDecl, id = 1 + toOrdinal(d, 0, { d' | d' is AnonOrNamedFun }), 
							 cn = strJoin("P_FUN_", d.name);
		d is AnonFunDecl, id = 1 + toOrdinal(d, 0, { d' | d' is AnonOrNamedFun }),
							 cn = strJoin("P_FUN_", strJoin(d.ownerFun, strJoin("_ANON", toString(d.anonFunIndex)))).

	HOut(0, out.EnmDef(NIL, "P_FUNS", list)) :-
		list = toList(#Elements, NIL, { enumMember |
									   enumMember = Element(IntLit(0, DEC, NIL), "_P_FUN_PUSH_OR_IGN"); 
									   DeclId(d, id, cn), d is AnonOrNamedFun, x = 2*id, enumMember = Element(IntLit(x, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_FUNS_COUNT"), size = 1 + count({d | d is AnonOrNamedFun}) }).

	HOut(0, def) :- d is AnonOrNamedFun, DeclId(d, _, funName), funStructName = strJoin(funName, "_STRUCT"),
	                        def = out.VarDef(
							      EXTERN, 
								  NmdType(NIL, "PRT_FUNDECL"), 
								  funStructName, 
								  NIL).

	//// Machine decls - Start at Id 0.
	DeclId(d, id, cn) :- d is MachineDecl, id = toOrdinal(d, 0, { d' | d' is MachineDecl }), cn = strJoin("P_MACHINE_", d.name).
	
	HOut(0, out.EnmDef(NIL, "P_MACHINES", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   DeclId(d, id, cn), d : MachineDecl, enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_MACHINES_COUNT"), size = count({d | d is MachineDecl}) }).  

	HOut(0, def) :- d is MachineDecl, machineName = strJoin("P_MACHINE_", d.name), machineStructName = strJoin(machineName, "_STRUCT"),
	                        def = out.VarDef(
							      EXTERN, 
								  NmdType(NIL, "PRT_MACHINEDECL"), 
								  machineStructName, 
								  NIL).

	//// Enum for renamed machine names
	HOut(0, out.EnmDef(NIL, "P_RENAME", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   CRenameMap(name, _), id = toOrdinal(name, 0, {n | CRenameMap(n, _)}), enumMember = Element(IntLit(id, DEC, NIL), strJoin("P_RENAME_", name)); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_RENAME_COUNT"), size = count({n | CRenameMap(n, _)}) }).  

	//// Enum for IorM
	HOut(0, out.EnmDef(NIL, "P_IORM", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   CLinkMap(_, iOrM, _), id = toOrdinal(iOrM, 0, {n | CLinkMap(_, n, _)}), enumMember = Element(IntLit(id, DEC, NIL), strJoin("P_IORM_", iOrM)); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_IORM_COUNT"), size = count({n | CLinkMap(_, n, _)}) }). 

	//// Extern declarations for defined types
	HOut(0, def) :- TypeDef(name, _), 
					typeName = strJoin("P_GEND_TYPE_", name),
					def = out.VarDef(EXTERN, PtrType(NmdType(NIL, "PRT_TYPE")), typeName, NIL).

	HOut(0, def) :- ModelType(name), 
					typeName = strJoin("P_GEND_TYPE_", name),
					def = out.VarDef(EXTERN, PtrType(NmdType(NIL, "PRT_TYPE")), typeName, NIL).
	
	//// Extern declarations for foreign type functions
	HOut(0, def) :- ModelType(name),
	                params = NIL,
				    funType = FunType(NmdType(NIL, "PRT_UINT64"), argTypes),
					argTypes = PrmTypes(BaseType(VOID), NIL),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_MKDEF_", strJoin(name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(0, def) :- ModelType(name),
	                params = Params(Param(NIL, "frgnVal"), NIL),
				    funType = FunType(NmdType(NIL, "PRT_UINT64"), argTypes),
					argTypes = PrmTypes(NmdType(NIL, "PRT_UINT64"), NIL),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_CLONE_", strJoin(name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(0, def) :- ModelType(name),
	                params = Params(Param(NIL, "frgnVal"), NIL),
				    funType = FunType(BaseType(VOID), argTypes),
					argTypes = PrmTypes(NmdType(NIL, "PRT_UINT64"), NIL),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_FREE_", strJoin(name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(0, def) :- ModelType(name),
	                params = Params(Param(NIL, "frgnVal"), NIL),
				    funType = FunType(NmdType(NIL, "PRT_UINT32"), argTypes),
					argTypes = PrmTypes(NmdType(NIL, "PRT_UINT64"), NIL),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_GETHASHCODE_", strJoin(name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(0, def) :- ModelType(name),
	                params = Params(Param(NIL, "frgnVal"), NIL),
				    funType = FunType(NmdType(NIL, "PRT_STRING"), argTypes),
					argTypes = PrmTypes(NmdType(NIL, "PRT_UINT64"), NIL),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_TOSTRING_", strJoin(name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(0, def) :- ModelType(name),
	                params = Params(Param(NIL, "frgnVal1"),
					         Params(Param(NIL, "frgnVal2"), 
							 NIL)),
				    funType = FunType(NmdType(NIL, "PRT_BOOLEAN"), argTypes),
					argTypes = PrmTypes(NmdType(NIL, "PRT_UINT64"), 
							   PrmTypes(NmdType(NIL, "PRT_UINT64"), 
							   NIL)),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_ISEQUAL_", strJoin(name, "_IMPL")),
					  params,
					  UNKNOWN).

	//// Extern declaration for Program Decl
	HOut(0, def) :- def = out.VarDef(
							      EXTERN, 
								  NmdType(NIL, "PRT_PROGRAMDECL"), 
								  "P_GEND_PROGRAM", 
								  NIL).

	/*************************************************************/
    /**********   Generate contents of code file     ***********/
    /*************************************************************/

	//// Labels a type expression with a number greater than the labels of all its sub-expressions.
	//// TypeId linearizes the dependency order to get a schedule for emitting type expressions.
	TypeId      ::= (id: Natural, type: TypeExpr).
	TypeDepNum  ::= (id: Natural, type: TypeExpr).

	TranslatedTypeExpr ::= (TypeExpr).
	TranslatedTypeExpr(t) :- t = in.BaseType(NULL); t = in.BaseType(BOOL); t = in.BaseType(INT); t = in.BaseType(EVENT); t = in.BaseType(MACHINE); t = in.BaseType(ANY).
	TranslatedTypeExpr(t) :- ModelType(name), t = NameType(name).
	TranslatedTypeExpr(t) :- EventDecl(_, _, t), t : TypeExpr.
	TranslatedTypeExpr(t) :- InterfaceTypeDecl(_, _, t).
	TranslatedTypeExpr(t) :- TypeDef(_, t).
	TranslatedTypeExpr(t) :- TranslatedTypeExpr(t'), t' = SeqType(t).
	TranslatedTypeExpr(t) :- TranslatedTypeExpr(t'), t' = MapType(t, _).
	TranslatedTypeExpr(t) :- TranslatedTypeExpr(t'), t' = MapType(_, t).
	TranslatedTypeExpr(t) :- TranslatedTypeExpr(t'), t' = TupType(t, _).  
	TranslatedTypeExpr(t) :- TranslatedTypeExpr(t'), t' = TupType(_, t), t: TypeExpr.  
	TranslatedTypeExpr(t) :- TranslatedTypeExpr(t'), t' = NmdTupType(NmdTupTypeField(_, t), _).
	TranslatedTypeExpr(t) :- TranslatedTypeExpr(t'), t' = NmdTupType(_, t), t: TypeExpr.  

	TypeDepNum(0, t) :- TranslatedTypeExpr(t), t : in.BaseType.
	TypeDepNum(0, t) :- TranslatedTypeExpr(t), t : in.NameType. 
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = in.SeqType(t'), TypeDepNum(j, t'), i = j + 1.  
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = in.MapType(t', t''), TypeDepNum(j, t'), TypeDepNum(k, t''),  i = j + k + 1.  
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = in.TupType(t', NIL), TypeDepNum(j, t'), i = j + 1.  
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = in.TupType(t', t''), TypeDepNum(j, t'), TypeDepNum(k, t''),  i = j + k + 1.  
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = in.NmdTupType(NmdTupTypeField(_, t'), NIL), TypeDepNum(j, t'), i = j + 1.  
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = in.NmdTupType(NmdTupTypeField(_, t'), t''), TypeDepNum(j, t'), TypeDepNum(k, t''), i = j + k + 1.  
	TypeId(id, t) :- td is TypeDepNum(_, t), id = toOrdinal(td, 0, { td' | td' is TypeDepNum }).

	//// Build type initializers in linearization order.
	//// defs is the definitions that precede the encoding of this type constant.
	TypeConstant ::= (type: TypeExpr + { NIL }, typeExprId: Integer, defs: out.Section + { NIL }).
	TypeConstant(NIL, -1, NIL).

	//// Base types
	BaseType2Kind ::= ({ NULL, BOOL, INT, EVENT, MACHINE, ANY }, String).
	BaseType2Kind(NULL, "PRT_KIND_NULL").
	BaseType2Kind(BOOL, "PRT_KIND_BOOL").
	BaseType2Kind(INT, "PRT_KIND_INT").
	BaseType2Kind(EVENT, "PRT_KIND_EVENT").
	BaseType2Kind(MACHINE, "PRT_KIND_MACHINE").
	BaseType2Kind(ANY, "PRT_KIND_ANY").
	
	TypeConstant(t, m, defs) :- TypeId(m, t), TypeConstant(_, m - 1, before), t = in.BaseType(base), BaseType2Kind(base, kind),
								defs = out.Section(before, def),
								def = out.VarDef(NIL, NmdType(NIL, "PRT_TYPE"), typeName, typeStruct),
								typeName = strJoin("P_GEND_TYPE_", toString(m)),
                                typeStruct = out.Init(Args(Ident(kind), Args(Init(Args(Ident("NULL"), NIL)), NIL))).						              

	//// Enum types
	TypeConstant(t, m, defs) :- TypeId(m, t), TypeConstant(_, m - 1, before), t = NameType(name), EnumTypeDef(name, _, _),
								defs = out.Section(before, def),
								def = out.VarDef(NIL, NmdType(NIL, "PRT_TYPE"), typeName, typeStruct),
								typeName = strJoin("P_GEND_TYPE_", toString(m)),
                                typeStruct = out.Init(Args(Ident("PRT_KIND_INT"), Args(Init(Args(Ident("NULL"), NIL)), NIL))).						              
	
	//// Foreign types
	TypeConstant(t, m, defs) :- TypeId(m, t), TypeConstant(_, m - 1, before), t = NameType(name), ModelType(name),
								defs = out.Section(before, def),
								def = out.VarDef(NIL, NmdType(NIL, "PRT_TYPE"), typeName, typeStruct),
								typeName = strJoin("P_GEND_TYPE_", toString(m)),
								indexName = strJoin("P_FORGN_TYPE_", name),
                                typeStruct = out.Init(Args(Ident("PRT_KIND_FORGN"), 
								                      Args(Init(Args(Cast(PtrType(NmdType(NIL, "PRT_MAPTYPE")), Ident(indexName)), NIL)), NIL))).						              
	
	//// Complex type Seq 
	//// (cast to PRT_MAPTYPE * is used to avoid compiler warnings when initializing union)
	TypeConstant(t, m, defs) :- TypeId(m, t), TypeConstant(_, m - 1, before), t = SeqType(tinner), TypeConstant(tinner, tinnerid, _),
								              defs = out.Section(Section(before, defSeq), def),
                              defSeq = out.VarDef(
                                     NIL, 
                                     NmdType(NIL, "PRT_SEQTYPE"), 
                                     typeNameSeq, 
                                     Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(tinnerid)))), NIL))),										 
                              def = out.VarDef(
                                     NIL, 
                                     NmdType(NIL, "PRT_TYPE"), 
                                     strJoin("P_GEND_TYPE_", toString(m)), 
                                     typeStruct),
								              typeStruct = out.Init(
										              Args(Ident("PRT_KIND_SEQ"), 
											            Args(Init(Args(Cast(PtrType(NmdType(NIL, "PRT_MAPTYPE")), UnApp(ADDR, Ident(typeNameSeq))), NIL)), 
											            NIL))),
									            typeNameSeq = strJoin("P_GEND_TYPE_SEQ_", toString(m)). 

	//// Complex type Map 
	TypeConstant(t, m, defs) :- 
	                       TypeId(m, t), TypeConstant(_, m - 1, before), t = MapType(tdom, tcod), 
	                       TypeConstant(tdom, domid, _), TypeConstant(tcod, codid, _),
								         defs = out.Section(Section(before, defMap), def),
										     defMap = out.VarDef(
										          NIL, 
														  NmdType(NIL, "PRT_MAPTYPE"), 
														  typeNameMap, 
														  Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(domid)))), 
														       Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(codid)))), 
														       NIL)))),
										      def = out.VarDef(
										          NIL, 
														  NmdType(NIL, "PRT_TYPE"), 
														  strJoin("P_GEND_TYPE_", toString(m)), 
														  typeStruct),
							            typeStruct = out.Init(
										            Args(Ident("PRT_KIND_MAP"), 
											          Args(Init(Args(UnApp(ADDR, Ident(typeNameMap)), NIL)), 
											          NIL))),														  
										      typeNameMap = strJoin("P_GEND_TYPE_MAP_", toString(m)).
	//// Complex type Tuple 
	Tup2ArrayInit ::= (type: TupType, arr: out.Expr). 
	Tup2ArrayInit(t, init) :- TranslatedTypeExpr(t), t = TupType(t', NIL), TypeConstant(t', id', _), init = Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(id')))), NIL)). 
	Tup2ArrayInit(t, init) :- TranslatedTypeExpr(t), t = TupType(t', t''), TypeConstant(t', id', _), Tup2ArrayInit(t'', Init(ts'')), 
	                          init = Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(id')))), ts'')). 

	TypeConstant(t, m, defs) :- 
	                       TypeId(m, t), TypeConstant(_, m - 1, before), Tup2ArrayInit(t, arrInit), t : TupType, 
								         defs = out.Section(Section(before, Section(defTupArr, defTup)), def),
										     defTupArr = out.VarDef(
										           NIL, 
															 ArrType(PtrType(NmdType(NIL, "PRT_TYPE")), NIL), 
															 typeNameTupArr, 
															 arrInit),
										     defTup = out.VarDef(
										          NIL, 
														  NmdType(NIL, "PRT_TUPTYPE"), 
														  typeNameTup, 
														  Init(
														    Args(IntLit(lstLength(#TupType, t), DEC, NIL), 
															  Args(Ident(typeNameTupArr), 
															  NIL)))),
										     def = out.VarDef(
										         NIL, 
													   NmdType(NIL, "PRT_TYPE"), 
													   strJoin("P_GEND_TYPE_", toString(m)), 
													   typeStruct),
										    typeStruct = out.Init(
													  Args(Ident("PRT_KIND_TUPLE"), 
													  Args(Init(Args(Cast(PtrType(NmdType(NIL, "PRT_MAPTYPE")), UnApp(ADDR, Ident(typeNameTup))), NIL)),
													  NIL))),
										     typeNameTupArr = strJoin("P_GEND_TYPE_TUP_ARR_", toString(m)),
										     typeNameTup = strJoin("P_GEND_TYPE_TUP_", toString(m)).

	//// Complex type NmdTuple 
	NmdTup2ArrayInit ::= (type: NmdTupType, narr: out.Expr, tarr: out.Expr). 
	NmdTup2ArrayInit(t, narr, tarr) :- TranslatedTypeExpr(t), t = NmdTupType(NmdTupTypeField(n', t'), NIL), TypeConstant(t', id', _), 
	                                   tarr = Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(id')))), NIL)), 
	                                   narr = Init(Args(StringLit(n', NIL), NIL)).
									    
	NmdTup2ArrayInit(t, narr, tarr) :- TranslatedTypeExpr(t), t = NmdTupType(NmdTupTypeField(n', t'), t''), TypeConstant(t', id', _), NmdTup2ArrayInit(t'', Init(n''), Init(ts'')), 
	                                   tarr = Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(id')))), ts'')),
	                                   narr = Init(Args(StringLit(n', NIL), n'')).

	TypeConstant(t, m, defs) :- TypeId(m, t), TypeConstant(_, m - 1, before), NmdTup2ArrayInit(t, narr, tarr), t : NmdTupType, 
								     defs = out.Section(before, Section(defNmdTupNArr, Section(defNmdTupTArr, Section(defNmdTup, def)))),
										 defNmdTupNArr = out.VarDef(
										              NIL, 
															    ArrType(NmdType(NIL, "PRT_STRING"), NIL), 
															    typeNameNmdTupNArr, 
															    narr),
										 defNmdTupTArr = out.VarDef(
										              NIL, 
															    ArrType(PtrType(NmdType(NIL, "PRT_TYPE")), NIL), 
															    typeNameNmdTupTArr, 
															    tarr),
										 defNmdTup = out.VarDef(
										          NIL, 
														  NmdType(NIL, "PRT_NMDTUPTYPE"), 
														  typeNameNmdTup, 
														  Init(
														  Args(IntLit(lstLength(#NmdTupType, t), DEC, NIL), 
															Args(Ident(typeNameNmdTupNArr), 
															Args(Ident(typeNameNmdTupTArr), 
															NIL))))),
										 def = out.VarDef(
										         NIL, 
													   NmdType(NIL, "PRT_TYPE"), 
													   strJoin("P_GEND_TYPE_", toString(m)), 
													   typeStatic),
							       typeStatic = out.Init(
										      Args(Ident("PRT_KIND_NMDTUP"), 
											    Args(Init(Args(Cast(PtrType(NmdType(NIL, "PRT_MAPTYPE")), UnApp(ADDR, Ident(typeNameNmdTup))), NIL)),
											    NIL))),
										 typeNameNmdTupTArr = strJoin("P_GEND_TYPE_NMDTUP_TARR_", toString(m)),
										 typeNameNmdTupNArr = strJoin("P_GEND_TYPE_NMDTUP_NARR_", toString(m)),
										 typeNameNmdTup = strJoin("P_GEND_TYPE_NMDTUP_", toString(m)).

    COut(0, defs) :- TypeConstant(_, c, defs), defs : out.Section, c = count({ td | td is TypeId}) - 1.
    
	/*************************************************************/
    /******   Generate C statics for typedefs in program   ******/
    /*************************************************************/
	TypeToExpr ::= (TypeExpr, Expr).
	TypeToExpr(type, expr) :- TypeId(typeIndex, type), expr = out.UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(typeIndex)))).

	COut(1, def) :- TypeDef(name, type),
	                typeName = strJoin("P_GEND_TYPE_", name), TypeToExpr(type, expr),
					def = out.VarDef(NIL, PtrType(NmdType(NIL, "PRT_TYPE")), typeName, expr).
	COut(1, def) :- ModelType(name), type = NameType(name),
	                typeName = strJoin("P_GEND_TYPE_", name), TypeToExpr(type, expr),
					def = out.VarDef(NIL, PtrType(NmdType(NIL, "PRT_TYPE")), typeName, expr).


	/*************************************************************/
    /******            Generate event decls                 ******/
    /*************************************************************/	
	EvDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).

	EvDecl2PayloadType ::= (EventDecl, out.Expr).
	//// An EventDecl without a payload type has a null payload type.
	EvDecl2PayloadType(d, expr) :- d is EventDecl(_, _, NIL), TypeToExpr(in.BaseType(NULL), expr).
	//// An EventDecl with a payload type refers to one of the statically generated types.
	EvDecl2PayloadType(d, expr) :- d is EventDecl(_, _, type), type : TypeExpr, TypeToExpr(type, expr).

	EvDecl2EvCard      ::= (EventDecl, out.Expr).
	//// An EventDecl without a queue constraint allows 2^32 - 1 events in a queue.
	EvDecl2EvCard(d, e) :- d is EventDecl(_, NIL, _), e = IntLit(4294967295, DEC, U).
	//// An EventDecl with a payload type refers to one of the statically generated types.
	EvDecl2EvCard(d, e) :- d is EventDecl(_, card, _), e = IntLit(card.bound, DEC, U).

	//// Base case
	EvDeclConcat(c, NIL) :- c = count({d | d is EventDecl}) + 2.

    //// Build event array in reverse order
	EvDeclConcat(m, arr) :- DeclId(d, m, cn), EvDeclConcat(m + 1, after), arr = out.Args(def, after), EvDecl2PayloadType(d, expr), EvDecl2EvCard(d, card), 
	                        def = Init(
							   Args(Ident(cn),
							   Args(StringLit(d.name, NIL),
							   Args(card,
							   Args(expr,
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))).

	//// Define the halt event
	EvDeclConcat(1, arr) :- EvDeclConcat(2, after), arr = out.Args(def, after), TypeConstant(in.BaseType(ANY), typeId, _),
	                        def = Init(
							   Args(Ident("_P_EVENT_HALT"),
							   Args(StringLit("halt", NIL),
							   Args(IntLit(4294967295, DEC, U),
							   Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(typeId)))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))).

	//// Define the default event
	EvDeclConcat(0, arr) :- EvDeclConcat(1, after), arr = out.Args(def, after), TypeConstant(in.BaseType(NULL), typeId, _),
	                        def = Init(
							   Args(Ident("_P_EVENT_NULL"),
							   Args(StringLit("null", NIL),
							   Args(IntLit(0, DEC, U),
							   Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(typeId)))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))).

    //// Emit the event decl array.
	COut(2, def) :- EvDeclConcat(0, arr), 
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_EVENTDECL"), NIL), 
								  "P_GEND_EVENTS", 
								  Init(arr)).

    /*************************************************************/
    /******         Generate EventSet Decl Arrays           ******/
    /*************************************************************/	
	EventPackList ::= (dat: EventPackData, tl: EventPackList + { NIL }).
	EventPackData ::= (arrIndex: Natural, events: Natural). 
	EventPacking  ::= (list: in.EventNameList + { NIL }, rem: EventPackList + { NIL }, arrIndex: Natural, packArr: out.Args + { NIL }).

	EventId ::= (trig: String + { NULL, HALT }, id: Natural).
	EventId(trig, id) :- trig : String, ev is EventDecl, ev.name = trig, DeclId(ev, id, _).
	EventId(NULL, id) :- DeclId(NULL, id, _).
	EventId(HALT, id) :- DeclId(HALT, id, _).

	EventSetId ::= (EventSet, in.EventNameList + { NIL }, in.EventName, Natural).
	EventSetId(eventset, list, ev, id) :- eventset is EventSet(_, in.EventNameList(ev, list)), EventId(ev, id).
	EventSetId(eventset, list, ev, id) :- EventSetId(eventset, in.EventNameList(ev, list), _, _), EventId(ev, id).

	EventPacking(eventset.list, rlist, size, NIL) :- 
		 eventset is EventSet,
		 list = toList(
		           #EventPackList, 
				   NIL, 
				   { EventPackData(i, n) | 
				        EventSetId(eventset, _, _, j), i = qtnt(j / 32, 1), 
				        n = sum(0, { m | EventSetId(eventset, _, _, k), i = qtnt(k / 32, 1), PowOf2(k % 32, m) }), n : Natural 
	               }),
		 rlist = lstReverse(#EventPackList, list),
		 highestEventIndex = 1 + count({decl | decl is EventDecl}), size = 1 + qtnt(highestEventIndex / 32, 1), size: Natural.

    //// Build up pack array.
	EventPacking(l, NIL, i', a') :- EventPacking(l, NIL, i, a), i > 0, i' = i - 1, i' : Natural, a' = Args(IntLit(0, HEX, U), a).
	EventPacking(l, r, i', a') :- EventPacking(l, r, i, a), i > 0, i' = i - 1, i' : Natural, r.dat.arrIndex < i', a' = Args(IntLit(0, HEX, U), a).
	EventPacking(l, r.tl, i', a') :- EventPacking(l, r, i, a), i > 0, i' = i - 1, i' : Natural, r.dat.arrIndex = i', a' = Args(IntLit(r.dat.events, HEX, U), a).

	COut(3, def) :- EventPacking(l, _, 0, a),
	                id = toOrdinal(l, 0, { l' | EventPacking(l', _, 0, _) }),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_UINT32"), NIL), 
								  strJoin("P_GEND_EVENTSET_", toString(id)), 
								  Init(a)).

    //// Build up event sets.
	EvSetDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).

	//// Base case
	EvSetDeclConcat(c, NIL) :- c = count({l | EventPacking(l, _, 0, _) }).

    //// Build every event set array in reverse order
	EvSetDeclConcat(m, arr) :- 
	                        EventPacking(l, _, _, NIL),
	                        m = toOrdinal(l, 0, { l' | EventPacking(l', _, 0, _) }),
							EvSetDeclConcat(m + 1, after),							  
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(IntLit(m, DEC, NIL),
							   Args(Ident(strJoin("P_GEND_EVENTSET_", toString(m))),
							   NIL))).

	COut(4, def) :- EvSetDeclConcat(0, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_EVENTSETDECL"), NIL), 
								  "P_GEND_EVENTSETS", 
								  Init(arr)).

    /*************************************************************/
    /******          Generate Global Fun Decl Array         ******/
    /*************************************************************/
	COut(4, def) :-			init = Init(
							   Args(Ident("_P_FUN_PUSH_OR_IGN"),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   Args(Ident("NULL"),
							   Args(IntLit(1, DEC, U),
							   Args(IntLit(0, DEC, U),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   Args(Ident("NULL"),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL)))))))))))))),
							def = out.VarDef(
							      NIL, 
								  NmdType(NIL, "PRT_FUNDECL"), 
								  "P_FUN_IGNORE_PUSH_STRUCT", 
								  init).
	
   	FunDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).

	FunDeclConcat(c, NIL) :- c = 1 + count({d | d is AnonOrNamedFun }).

	FunDeclConcat(m, arr) :-  
							DeclId(d, m, cn), FunDeclConcat(m + 1, after), d : AnonOrNamedFun,
							funStructName = strJoin(cn, "_STRUCT"),
							arr = out.Args(def, after),
							def = UnApp(ADDR, Ident(funStructName)).

	//// Reserve the zeroth decl for the ignore/push transition
	FunDeclConcat(0, arr) :- FunDeclConcat(1, after), arr = out.Args(def, after), def = UnApp(ADDR, Ident("P_FUN_IGNORE_PUSH_STRUCT")).

	COut(5, def) :- FunDeclConcat(0, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(PtrType(NmdType(NIL, "PRT_FUNDECL")), NIL), 
								  "P_GEND_FUNS", 
								  Init(arr)).

    /*************************************************************/
    /******          Generate Machine Decl Arrays           ******/
    /*************************************************************/	
	MachineDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).
	MachineDeclConcat(c, NIL) :- c = count({m | m is MachineDecl}).
	MachineDeclConcat(m, arr) :- 
							DeclId(d, m, _), d : MachineDecl, 
							machineName = strJoin("P_MACHINE_", d.name), machineStructName = strJoin(machineName, "_STRUCT"),
							MachineDeclConcat(m + 1, after),  
							arr = out.Args(def, after),
							def = UnApp(ADDR, Ident(machineStructName)).

	COut(5, def) :- MachineDeclConcat(0, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(PtrType(NmdType(NIL, "PRT_MACHINEDECL")), NIL), 
								  "P_GEND_MACHINES", 
								  Init(arr)).

    /*************************************************************/
    /******     Generate Foreign Type Decl Arrays           ******/
    /*************************************************************/	
	ForeignTypeDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).

	//// Base case
	ForeignTypeDeclConcat(c, NIL) :- c = count({name | ModelType(name)}).

	ForeignTypeDeclConcat(m, arr) :- 
							ModelType(name), m = toOrdinal(name, 0, { n | ModelType(n) }),
							ForeignTypeDeclConcat(m + 1, after),  
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(Ident(strJoin("P_FORGN_TYPE_", name)),
							   Args(StringLit(name, NIL),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_MKDEF_", strJoin(name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_CLONE_", strJoin(name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_FREE_", strJoin(name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_GETHASHCODE_", strJoin(name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_ISEQUAL_", strJoin(name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_TOSTRING_", strJoin(name, "_IMPL")))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))))))).

	COut(5, def) :- ForeignTypeDeclConcat(0, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_FOREIGNTYPEDECL"), NIL), 
								  "P_GEND_FOREIGNTYPES", 
								  Init(arr)).

    /*************************************************************/
    /******     Generate Rename Map and Link Map Arrays     ******/
    /*************************************************************/	
	RenameMapDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).
	RenameMapDeclConcat(c, NIL) :- c = count({n | CRenameMap(n, _)}).
	RenameMapDeclConcat(m, arr) :- 
							mdecl is MachineDecl, DeclId(mdecl, _, machineName), 
							CRenameMap(name, mdecl.name), m = toOrdinal(name, 0, {n | CRenameMap(n, _)}),
							RenameMapDeclConcat(m + 1, after),  
							arr = out.Args(Ident(machineName), after).

	COut(5, def) :- RenameMapDeclConcat(0, arr),
					def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_UINT32"), NIL), 
								  "P_GEND_RENAMEMAP", 
								  Init(arr)).

	LinkMapDeclInnerConcat ::= (name: String, pos: Natural, arr: out.Args + {NIL}).
	LinkMapDeclInnerConcat(name, c, NIL) :- CRenameMap(name, _), c = count({n | CLinkMap(_, n, _)}).
	LinkMapDeclInnerConcat(name, m, arr) :- 
							CLinkMap(name, mOrI, x), xid = toOrdinal(x, 0, {n | CRenameMap(n, _)}),
							m = toOrdinal(mOrI, 0, {n | CLinkMap(_, n, _)}),
							LinkMapDeclInnerConcat(name, m + 1, after),  
							arr = out.Args(IntLit(xid, DEC, U), after).
	LinkMapDeclInnerConcat(name, m, arr) :- 
							CRenameMap(name, _), CLinkMap(_, mOrI, _), no CLinkMap(name, mOrI, _), 
							m = toOrdinal(mOrI, 0, {n | CLinkMap(_, n, _)}),
							LinkMapDeclInnerConcat(name, m + 1, after),  
							arr = out.Args(Ident("_P_RENAME_COUNT"), after).
	COut(5, def) :- LinkMapDeclInnerConcat(name, 0, arr),
					def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_UINT32"), NIL), 
								  strJoin("P_GEND_LINKMAP_", name), 
								  Init(arr)).
	
	LinkMapDeclOuterConcat ::= (pos: Natural, arr: out.Args + {NIL}).
	LinkMapDeclOuterConcat(c, NIL) :- c = count({n | LinkMapDeclInnerConcat(n, _, _)}).
	LinkMapDeclOuterConcat(m, arr) :- 
							LinkMapDeclInnerConcat(name, 0, args),
							m = toOrdinal(name, 0, {n | LinkMapDeclInnerConcat(n, _, _)}), 
							LinkMapDeclOuterConcat(m + 1, after),
							arr = out.Args(Ident(strJoin("P_GEND_LINKMAP_", name)), after).
	
	COut(6, def) :- LinkMapDeclOuterConcat(0, arr),
					def = out.VarDef(
							      NIL, 
								  ArrType(PtrType(NmdType(NIL, "PRT_UINT32")), NIL), 
								  "P_GEND_LINKMAP", 
								  Init(arr)).

    /*************************************************************/
    /******            Generate Program Decl                ******/
    /*************************************************************/	

	ProgEvntArray ::= (size: Natural, arr: out.Ident).
	ProgEvntArray(size, arr) :- size = 2 + count({ e | e is EventDecl }), arr = out.Ident("P_GEND_EVENTS").

	ProgEvntSetArray ::= (size: Natural, arr: out.Ident).
	ProgEvntSetArray(size, arr) :- size = count({ l | EventPacking(l, _, 0, _) }), size = 0, arr = out.Ident("NULL").
	ProgEvntSetArray(size, arr) :- size = count({ l | EventPacking(l, _, 0, _) }), size > 0, arr = out.Ident("P_GEND_EVENTSETS").

	ProgMachArray ::= (size: Natural, arr: out.Ident).
	ProgMachArray(size, arr) :- size = count({ m | m is MachineDecl }), size = 0, arr = out.Ident("NULL").
	ProgMachArray(size, arr) :- size = count({ m | m is MachineDecl }), size > 0, arr = out.Ident("P_GEND_MACHINES").

	ProgGlobalFunArray ::= (size: Natural, arr: out.Ident).
	ProgGlobalFunArray(size, arr) :- size = 1 + count({ m | m is AnonOrNamedFun }), arr = out.Ident("P_GEND_FUNS").

	ProgForeignTypesArray ::= (size: Natural, arr: out.Ident).
	ProgForeignTypesArray(size, arr) :- size = count({ n | ModelType(n) }), size = 0, arr = out.Ident("NULL").
	ProgForeignTypesArray(size, arr) :- size = count({ n | ModelType(n) }), size > 0, arr = out.Ident("P_GEND_FOREIGNTYPES").

	LinkMapArray ::= (arr: out.Ident).
	LinkMapArray(arr) :- size = count({n | LinkMapDeclInnerConcat(n, _, _)}), size = 0, arr = out.Ident("NULL").
	LinkMapArray(arr) :- size = count({n | LinkMapDeclInnerConcat(n, _, _)}), size > 0, arr = out.Ident("P_GEND_LINKMAP").

	RenameMapArray ::= (arr: out.Ident).
	RenameMapArray(arr) :- size = count({n | CRenameMap(n, _)}), size = 0, arr = out.Ident("NULL").
	RenameMapArray(arr) :- size = count({n | CRenameMap(n, _)}), size > 0, arr = out.Ident("P_GEND_RENAMEMAP").

	COut(7, def) :-  ProgEvntArray(evArrSize, evArrName),
	                 ProgEvntSetArray(evSetArrSize, evSetArrName),
					 ProgMachArray(machArrSize, machArrName),
					 ProgGlobalFunArray(globalFunArrSize, globalFunArrName),
					 ProgForeignTypesArray(foreignTypesSize, foreignTypesArrName),
					 LinkMapArray(linkMapArrName),
					 RenameMapArray(renameMapArrName),
	                 def = out.VarDef(
							      NIL, 
								  NmdType(NIL, "PRT_PROGRAMDECL"), 
								  "P_GEND_PROGRAM", 
								  init),
				     init = Init(
							   Args(IntLit(evArrSize, DEC, U),
							   Args(IntLit(evSetArrSize, DEC, U),
							   Args(IntLit(machArrSize, DEC, U),
							   Args(IntLit(globalFunArrSize, DEC, U),
							   Args(IntLit(foreignTypesSize, DEC, U),
							   Args(evArrName,
							   Args(evSetArrName,
							   Args(machArrName,
							   Args(globalFunArrName,
							   Args(foreignTypesArrName,
							   Args(linkMapArrName,
							   Args(renameMapArrName,
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))))))))))).

	/*************************************************************/
    /******                 Powers of two                   ******/
    /*************************************************************/	

	PowOf2 ::= (exp: {0..31}, val: Natural).

	PowOf2(0, 1).          PowOf2(1, 2).          PowOf2(2, 4).           PowOf2(3, 8).
	PowOf2(4, 16).         PowOf2(5, 32).         PowOf2(6, 64).          PowOf2(7, 128).
	PowOf2(8, 256).        PowOf2(9, 512).        PowOf2(10, 1024).       PowOf2(11, 2048).
	PowOf2(12, 4096).      PowOf2(13, 8192).      PowOf2(14, 16384).      PowOf2(15, 32768).
	PowOf2(16, 65536).     PowOf2(17, 131072).    PowOf2(18, 262144).     PowOf2(19, 524288).
	PowOf2(20, 1048576).   PowOf2(21, 2097152).   PowOf2(22, 4194304).    PowOf2(23, 8388608).
	PowOf2(24, 16777216).  PowOf2(25, 33554432).  PowOf2(26, 67108864).   PowOf2(27, 134217728).
	PowOf2(28, 268435456). PowOf2(29, 536870912). PowOf2(30, 1073741824). PowOf2(31, 2147483648).

}